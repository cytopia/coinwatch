#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# The MIT License (MIT)
#
# Copyright (c) 2018 cytopia <cytopia@everythingcli.org>

'''
Coinwatch is a low-dependency python[23] client to keep track of your
crypto trades and easily let's you see if you are winning or losing.

No financial aid, support or any other recommendation is provided.
Trade at your own risk! And only invest what you can effort to lose.

Currently supported API's are:
  - coinmarketcap
'''


############################################################
# Imports
############################################################

# Make it work for python2 and python3
from __future__ import print_function
from __future__ import unicode_literals

try:
    # For Python 3.0 and later
    from urllib.request import Request, urlopen
    from urllib.error import URLError, HTTPError
except ImportError:
    # Fall back to Python 2's urllib2
    from urllib2 import Request, urlopen
    from urllib2 import URLError, HTTPError

# Default imports
from decimal import Decimal, getcontext, localcontext
from random import randint
import os
import getopt
import sys
import re
import json

# External dependencies
import yaml

# Force Python2 to use utf8
try:
    reload(sys)  # noqa
    sys.setdefaultencoding('utf8')
except Exception:
    # Not required and won't work on Python3, so
    # do not break on error, but just be silent.
    pass


############################################################
# Globals
############################################################

NAME = 'coinwatch'
AUTHOR = 'cytopia'
VERSION = '0.8'
API_URL = 'https://api.coinmarketcap.com/v1/ticker/?limit=0'


# Row settings
COL_SETTINGS = {
    # colname    #col width    #col align     #precision   #color          #headline
    'name':      {'width': 13, 'align': '<', 'prec': None, 'color': False, 'head': 'CURRENCY'},
    'date':      {'width': 10, 'align': '<', 'prec': None, 'color': False, 'head': 'BUY DATE'},
    'buyprice':  {'width': 14, 'align': '>', 'prec':    6, 'color': False, 'head': '$ BUY PRICE/c'},
    'diffprice': {'width': 15, 'align': '>', 'prec':    6, 'color': True, 'head': '$ DIFF PRICE/c'},
    'nowprice':  {'width': 14, 'align': '>', 'prec':    6, 'color': False, 'head': '$ NOW PRICE/c'},
    'amount':    {'width': 16, 'align': '>', 'prec':    6, 'color': False, 'head': 'NUM COINS'},
    'invest':    {'width': 10, 'align': '>', 'prec':    2, 'color': False, 'head': '$ INVEST'},
    'wealth':    {'width': 10, 'align': '>', 'prec':    2, 'color': False, 'head': '$ WEALTH'},
    'profit':    {'width': 12, 'align': '>', 'prec':    2, 'color': True, 'head': '$ PROFIT'},
    'percent':   {'width':  7, 'align': '>', 'prec':    1, 'color': False, 'head': 'PERCENT'}
}
# All available columns
COL_AVAILABLE = [
    'name',
    'date',
    'buyprice',
    'diffprice',
    'nowprice',
    'amount',
    'invest',
    'wealth',
    'profit',
    'percent'
]
# Default columns to display if not otherwise overwritten via
# configuration file or command line arguments
COL_DEFAULT = [
    'name',
    'date',
    'buyprice',
    'diffprice',
    'nowprice',
    'amount',
    'invest',
    'wealth',
    'profit',
    'percent'
]


EXAMPLE_CONFIG = '''---
#
# coinwatch config
#
# Remote API: https://api.coinmarketcap.com/v1/ticker/?limit=0
#
#
# Config file description
# -----------------------
# trades:
#   # CURRENCY_ID is found by looking up the 'id' key from
#   # https://api.coinmarketcap.com/v1/ticker/?limit=0
#   CURRENCY_ID:  # <-- [array]       Each currency will hold a list of trades
#     - amount:   # <-- [decimal]     [1] How many coins for that currency were bought
#       invest:   # <-- [decimal]     [1] How much money was spent on all coins
#       price:    # <-- [decimal]     [1] Price for 1 coin on that date
#       date:     # <-- [yyyy-mm-dd]  When was that bought
#
# [1] IMPORTANT: Only always specify two of 'amount', 'invest' and 'price'.
#                The third value will always be calculated from the other two.
#
# [1] Trades can/must be configured in three different ways:
# Option-1
#     amount: how many coins bought
#     invest: how much money spent on all coins
# Option-2
#     amount: how many coins bought
#     price:  price for one coin
# Option-3
#     invest: how much money spent on all coins
#     price:  price for one coin

# Example config:
# ---------------

# Configure coinwatch
config:
  # Specify the column to sort this table
  sort: name
  # Specify the sort order (asc or desc)
  order: asc
  # Configure what columns to display and in what order.
  # To see all available columns view help: $ coinwatch --help
  # Columns specified via command line (-r) take precedence
  columns: name date buyprice diffprice nowprice amount invest wealth profit percent
  # Specify your table border style
  # Available values: thin, thick and ascii
  # Use ascii if you want to further process the output of this application
  table: thin

# Configure your purchases
trades:
  bitcoin:
    # Options-1
    - amount:  5.323
      invest:  35432.23
      date:    2017-12-05
    # Options-2
    - amount:  0.001
      price:   110323.54
      date:    2018-01-27
    # Options-3
    - invest:  100
      price:   110323.54
      date:    2018-01-27
  ethereum:
    - amount:  20
      price:   1070
      date:    2017-12-05
  iota: []
'''


############################################################
# Class: Color
############################################################

class Color(object):
    '''Class that returns shell color codes if desired.'''

    def __init__(self, enable):
        '''Enable or disable color support'''
        if enable:
            self.__clr_blue = '\033[94m'
            self.__clr_green = '\033[92m'
            self.__clr_yellow = '\033[93m'
            self.__clr_red = '\033[91m'
            self.__clr_reset = '\033[0m'
        else:
            self.__clr_blue = ''
            self.__clr_green = ''
            self.__clr_yellow = ''
            self.__clr_red = ''
            self.__clr_reset = ''

    def blue(self):
        '''Return blue color code'''
        return self.__clr_blue

    def green(self):
        '''Return green color code'''
        return self.__clr_green

    def yellow(self):
        '''Return yellow color code'''
        return self.__clr_yellow

    def red(self):
        '''Return red color code'''
        return self.__clr_red

    def reset(self):
        '''Return reset color code'''
        return self.__clr_reset


############################################################
# Class: Num
############################################################

class Num(object):
    '''Wrapper to ensure correct variable type for numbers'''

    __precision = 45

    @staticmethod
    def __num(number):
        '''Convert to correct format'''
        with localcontext() as ctx:
            ctx.prec = Num.__precision
            return Decimal(str(number))

    @staticmethod
    def __zero():
        '''Get zero'''
        return Num.__num(0)

    @staticmethod
    def get(number):
        '''Make sure to use Decimal'''
        return Num.__num(number)

    @staticmethod
    def sum(num1, num2):
        '''Addition'''
        with localcontext() as ctx:
            ctx.prec = Num.__precision
            return Num.__num(num1) + Num.__num(num2)

    @staticmethod
    def sub(num1, num2):
        '''Substraction'''
        with localcontext() as ctx:
            ctx.prec = Num.__precision
            return Num.__num(num1) - Num.__num(num2)

    @staticmethod
    def mul(num1, num2):
        '''Multiplication'''
        with localcontext() as ctx:
            ctx.prec = Num.__precision
            return Num.__num(num1) * Num.__num(num2)

    @staticmethod
    def div(num1, num2):
        '''Division'''
        with localcontext() as ctx:
            ctx.prec = Num.__precision
            if Num.iszero(num2):
                return Num.__num(getcontext().Emax)
            return Num.__num(num1) / Num.__num(num2)

    @staticmethod
    def iszero(number):
        '''Check if number is zero'''
        with localcontext() as ctx:
            ctx.prec = Num.__precision
            return bool(Num.__num(number) == Num.__zero())

    @staticmethod
    def percent(whole, part):
        '''Percent'''
        return Num.div(
            Num.mul(100, whole),
            part
        )

    @staticmethod
    def round(number, precision):
        '''Round a number to the given precision'''
        with localcontext() as ctx:
            ctx.prec = Num.__precision
            # E.g.: precision=3: '1.000'
            quantizer = Decimal(str('1.' + str('0' * precision)))
            return Num.__num(number).quantize(quantizer)

    @staticmethod
    def to_string(number, precision):
        '''Return string value and round to Xth precision'''
        number = Num.round(number, precision)
        return ('{0:,.' + str(precision) + 'f}').format(number)


############################################################
# Class: Table
############################################################

class Table(object):
    '''Custom command line table drawer class'''

    # Table content
    __data = {
        'rows': [],   # The actual rows of the table (sortable and groupable)
        'heads': [],  # Header rows (not sortable, not groupable)
        'foots': []   # Footer rows (not sortable, not groupable)
    }

    # Defaults if not set
    __defaults = {
        'width': 10,      # Default column width
        'align': '<',     # Default column alignt.('<': left, '=': center, '>':right)
        'border': 'thin'  # Default table border
    }

    # Name of columns that can be added to the table.
    # This is set in __init__
    # Format:
    # ['colname1', 'colname2']
    __columns = []

    # Width and align settings for columns
    # Format:
    # {
    #    'colname1': {'width': X, 'align': '<'},
    #    'colname2': {'width': X, 'align': '<'}
    # }
    __col_settings = dict()

    # Actual chosen border symbols (see __init__)
    __sym = dict()

    # Available table border styles
    __sym_border = {
        'ascii': {
            'top-lft': '|',
            'top-rgt': '|',
            'top-cen': '-',
            'mid-lft': '|',
            'mid-rgt': '|',
            'mid-cen': '|',
            'bot-lft': '|',
            'bot-rgt': '|',
            'bot-cen': '-',
            'hor-sep': '-',
            'ver-sep': '|'
        },
        'thin': {
            'top-lft': '┌',
            'top-rgt': '┐',
            'top-cen': '┬',
            'mid-lft': '├',
            'mid-rgt': '┤',
            'mid-cen': '┼',
            'bot-lft': '└',
            'bot-rgt': '┘',
            'bot-cen': '┴',
            'hor-sep': '─',
            'ver-sep': '│'
        },
        'thick': {
            'top-lft': '╔',
            'top-rgt': '╗',
            'top-cen': '╦',
            'mid-lft': '╠',
            'mid-rgt': '╣',
            'mid-cen': '╬',
            'bot-lft': '╚',
            'bot-rgt': '╝',
            'bot-cen': '╩',
            'hor-sep': '═',
            'ver-sep': '║'
        }
    }

    def __init__(self, columns, border):
        '''
        Initializes the Table object

        columns   list of coumn names. E.g.: ['colname1', 'colname2', 'colname3']
                  This specifies the initial order or columns as well as
                  the number of columns.
                  Those names are later used to change order, width, grouping
                  as well as what columns to actually display.
        border    What table border to use
        '''
        # Store number of columns
        self.__columns = columns

        # Set table border style
        if border == 'thin':
            self.__sym = self.__sym_border['thin']
        elif border == 'thick':
            self.__sym = self.__sym_border['thick']
        else:
            self.__sym = self.__sym_border['ascii']

        # Set colum aligns and width with defaults
        self.set_col_aligns()
        self.set_col_widths()

    @staticmethod
    def __remove_ansi(string):
        '''Remove ANSI escape sequences and spaces'''
        regex = re.compile(r'\x1B\[[0-?]*[ -/]*[@-~]', re.UNICODE)
        return regex.sub('', str(string)).strip()

    @staticmethod
    def __ansilen(string):
        '''Get string length without ansi escape codes'''
        return len(Table.__remove_ansi(string))

    def __sort_rows(self, column=None, reverse=False):
        '''Sort all data rows (excluding headers and footers by given column)'''

        # Only sort if the sort key actually exists
        if column in self.__columns:
            # Try to sort float numbers
            try:
                self.__data['rows'] = sorted(
                    self.__data['rows'],
                    key=lambda x: float(Table.__remove_ansi(x[column]).replace(',', '')),
                    reverse=reverse
                )
            # Fall-back on string sort
            except ValueError:
                self.__data['rows'] = sorted(
                    self.__data['rows'],
                    key=lambda x: Table.__remove_ansi(x[column]),
                    reverse=reverse
                )

    def __get_row(self, display_columns, data):
        '''
        Returns the formatted row string by applying format()

        display_columns  List of columns to actually display.
                         Required to know know how many columns are in one row.
        data             List of columns. This is required to calculate
                         their width without ANSI escape sequences in order to properly
                         re-calculate the width of a column.
        '''
        # Get symbols in local var for better readability
        sym = self.__sym

        # Start with left cell separator
        row = sym['ver-sep']

        # Create row format with correct alignment and width
        for column in display_columns:
            # 1. Get alignment
            align = self.__col_settings[column]['align']
            # 2. Get width
            width = self.__col_settings[column]['width']
            # 3. Adjust width in case our string contains ANSI escape sequences
            if len(str(data[column])) != Table.__ansilen(data[column]):
                diff = len(str(data[column])) - Table.__ansilen(data[column])
                width += diff

            row += ' {:' + align + str(width) + '} ' + sym['ver-sep']

        return row.format(*[data[col] for col in display_columns])

    def __get_sep(self, display_columns, position):
        '''
        Returns the formatted separator string by applying format().

        display_columns  List of columns to actually display.
                         Required to know know how many columns are in one row.

        position         Where is the separator located?
                         'top': First separator that starts the table
                         'mid': Separator between rows
                         'bot': Last separator that closes the table
        '''
        # Get symbols in local var for better readability
        sym = self.__sym

        # Start with left cell separator
        row = sym[position + '-lft']

        # Create row format based on columns to display
        for column in display_columns:
            # 1. Get width
            width = self.__col_settings[column]['width']
            row += sym['hor-sep'] + \
                '{:' + sym['hor-sep'] + '<' + str(width) + '}' + \
                sym['hor-sep'] + sym[position + '-cen']

        row = row[:-1] + sym[position + '-rgt']  # Adjust last char
        return row.format(*['' for i in range(len(display_columns))])

    def set_col_widths(self, widths=dict()):
        '''
        Set colum widths.
        If colum width is not set, default_width will be used.

        widths   Dictionary of widths.
                 E.g.: list('name': 10, 'col2': 20)
                 It must match the index names specified in __init__
        '''
        # Loop over available columns and see if width for it is specified.
        # If not specified for a column, use the Class's default width.
        for col in self.__columns:
            if col in widths:
                if col in self.__col_settings:
                    self.__col_settings[col]['width'] = widths[col]
                else:
                    self.__col_settings[col] = {'width': widths[col]}
            else:
                if col in self.__col_settings:
                    self.__col_settings[col]['width'] = self.__defaults['width']
                else:
                    self.__col_settings[col] = {'width': self.__defaults['width']}

    def set_col_aligns(self, aligns=dict()):
        '''
        Set colum alignments.
        If colum align is not set, default_align will be used.

        aligns   Dictionary of aligns.
                 E.g.: list('name': '<', 'col2': '=')
                 It must match the index names specified in __init__
        '''
        # Loop over available columns and see if align for it is specified.
        # If not specified for a column, use the Class's default align.
        for col in self.__columns:
            if col in aligns:
                if col in self.__col_settings:
                    self.__col_settings[col]['align'] = aligns[col]
                else:
                    self.__col_settings[col] = {'align': aligns[col]}
            else:
                if col in self.__col_settings:
                    self.__col_settings[col]['align'] = self.__defaults['align']
                else:
                    self.__col_settings[col] = {'align': self.__defaults['align']}

    def add_row(self, columns):
        '''
        Add a new row to the table
        columns  Dictionary of columns to add to a row.
                 E.g.: list('name': val, 'col2': val)
                 It must match the index names specified in __init__
        '''
        self.__data['rows'].append(columns)

    def add_header_row(self, columns):
        '''
        Add a new headline row to the table
        columns  Dictionary of columns to add to a row.
                 E.g.: list('name': val, 'col2': val)
                 It must match the index names specified in __init__
        '''
        self.__data['heads'].append(columns)

    def add_footer_row(self, columns):
        '''
        Add a new footer row to the table
        columns  Dictionary of columns to add to a row.
                 E.g.: list('name': val, 'col2': val)
                 It must match the index names specified in __init__
        '''
        self.__data['foots'].append(columns)

    def draw(self, columns=None, sort_col=None, sort_order='asc', group_col=None):
        '''
        Draw the table.

        columns         List of columns to draw in the order it is in the list.
                        If not specified, all columns will be drawn in the order
                        it was specified during __init__.
        sort_col        Sort columns by this column name.
                        If not specified, no sorting will be done.
        sort_order      Sort oder 'asc' or 'desc'.
        group_col       Group columns by this column name.
                        If not specified, no grouping will be done.
        '''
        print(
            self.get(columns, sort_col, sort_order, group_col)
        )

    def get(self, columns=None, sort_col=None, sort_order='asc', group_col=None):
        '''
        Return the table as string.

        columns         List of columns to get in the order it is in the list.
                        If not specified, all columns will be used in the order
                        it was specified during __init__.
        sort_col        Sort columns by this column name.
                        If not specified, no sorting will be done.
        sort_order      Sort oder 'asc' or 'desc'.
        group_col       Group columns by this column name.
                        If not specified, no grouping will be done.
        '''

        # What columns to display and in what order
        display_columns = []
        if isinstance(columns, list) and columns:
            display_columns = columns
        else:
            display_columns = self.__columns

        # Get seperators
        sep_top = self.__get_sep(display_columns, 'top')
        sep_mid = self.__get_sep(display_columns, 'mid')
        sep_bot = self.__get_sep(display_columns, 'bot')

        # Sort rows
        if sort_order == 'asc':
            self.__sort_rows(sort_col, False)
        else:
            self.__sort_rows(sort_col, True)

        # TODO: Implement grouping

        rows = []
        for row in self.__data['rows']:
            rows.append(self.__get_row(display_columns, row))

        heads = []
        for row in self.__data['heads']:
            heads.append(self.__get_row(display_columns, row))

        foots = []
        for row in self.__data['foots']:
            foots.append(self.__get_row(display_columns, row))

        # Build the table
        table = sep_top + '\n'

        if heads:
            table += ('\n' + sep_mid + '\n').join(heads) + '\n' + sep_mid + '\n'
        if rows:
            table += ('\n' + sep_mid + '\n').join(rows) + '\n'
        if foots:
            table += sep_mid + '\n' + ('\n' + sep_mid + '\n').join(foots) + '\n'

        table += sep_bot

        return table


############################################################
# Class: Fetch
############################################################

class Fetch(object):
    '''Fetch URL from remote'''

    __settings = {
        'randomize_ua': True,
    }
    __useragents = [
        'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0; .NET CLR 1.0.3705)',
        'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; FSL 7.0.5.01003)',
        'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; FSL 7.0.6.01001)',
        'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; FSL 7.0.7.01001)',
        'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:57.0) Gecko/20100101 Firefox/57.0',
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:57.0) Gecko/20100101 Firefox/57.0',
        'Mozilla/5.0 (Windows NT 5.1; rv:13.0) Gecko/20100101 Firefox/13.0.1',
        'Mozilla/5.0 (Windows NT 5.1; rv:13.0) Gecko/20100101 Firefox/13.0.1',
        'Mozilla/5.0 (Windows NT 5.1; rv:5.0.1) Gecko/20100101 Firefox/5.0.1',
        'Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; rv:11.0) like Gecko',
        'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:12.0) Gecko/20100101 Firefox/12.0',
        'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:13.0) Gecko/20100101 Firefox/13.0.1',
        'Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:57.0) Gecko/20100101 Firefox/57.0',
        'Mozilla/5.0 (Windows NT 6.1; rv:5.0) Gecko/20100101 Firefox/5.02',
        'Mozilla/5.0 (X11; Linux x86_64; rv:57.0) Gecko/20100101 Firefox/57.0',
        'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:57.0) Gecko/20100101 Firefox/57.0',
        'Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0)',
        'Opera/9.80 (Windows NT 5.1; U; en) Presto/2.10.289 Version/12.01'
    ]

    def __init__(self, randomize_ua=True):
        '''Initialize'''
        self.__settings = {
            'randomize_ua': randomize_ua
        }

    def __get_ua(self):
        '''Get random useragent'''
        index = randint(0, len(self.__useragents)-1)
        return self.__useragents[index]

    def fetch(self, url):
        '''Fetch url and return its body'''

        headers = dict()
        if self.__settings['randomize_ua']:
            headers = {'User-Agent': self.__get_ua()}

        req = Request(url, headers=headers)
        try:
            response = urlopen(req)
        except HTTPError:
            raise
        except URLError:
            raise
        else:
            return response.read().decode('utf-8')


############################################################
# Class: Coinwatch
############################################################

class Coinwatch(object):
    '''Coinwatch Class'''

    # General output settings
    __settings = {
        'color': False,    # Colorize output?
        'human': False,    # Humanize number output?
        'sort':  'name',   # Default sort column
        'order': 'asc',    # Default sort order
        'table': 'thick',  # Table border style
        'cols':  dict()    # Columns to display
    }

    # Specific settings for each column
    __col_settings = dict()

    def __init__(self, settings, col_settings):
        '''Set settings'''
        self.__settings = settings
        self.__col_settings = col_settings

    @staticmethod
    def __get_amount(trade):
        '''Returns amount based on amount, invest and price'''

        if 'amount' in trade:
            return Num.get(trade['amount'])
        # amount needs to be calculated
        invest = Num.get(trade.get('invest', 0))
        price = Num.get(trade.get('price', 0))
        return Num.div(invest, price)

    @staticmethod
    def __get_invest(trade):
        '''Returns invest based on amount, invest and price'''

        if 'invest' in trade:
            return Num.get(trade['invest'])
        # Invest needs to be calculated
        amount = Num.get(trade.get('amount', 0))
        price = Num.get(trade.get('price', 0))
        return Num.mul(price, amount)

    @staticmethod
    def __get_price(trade):
        '''Returns price based on amount, invest and price'''

        if 'price' in trade:
            return Num.get(trade['price'])
        # Price needs to be calculated
        invest = Num.get(trade.get('invest', 0))
        amount = Num.get(trade.get('amount', 0))
        return Num.div(invest, amount)

    @staticmethod
    def __extract_trade_row_values(currency, price, trade):
        '''
        Extract values of one trade list item, calculate all other necessary
        values and combine with current price and crypto name.
        trade: {date, price, invest, amount}
        '''
        amount = Coinwatch.__get_amount(trade)
        invest = Coinwatch.__get_invest(trade)
        buyprice = Coinwatch.__get_price(trade)
        nowprice = Num.get(price)

        # Calculate diffprice, wealth, profit and percent
        diffprice = Num.sub(nowprice, buyprice)
        wealth = Num.mul(nowprice, amount)
        profit = Num.sub(wealth, invest)
        percent = Num.percent(wealth, invest)

        return {
            'name':      currency,
            'date':      str(trade.get('date', '-')),
            'buyprice':  buyprice,
            'diffprice': diffprice,
            'nowprice':  nowprice,
            'amount':    amount,
            'invest':    invest,
            'wealth':    wealth,
            'profit':    profit,
            'percent':   percent
        }

    @staticmethod
    def __humanize_number(number, precision):
        '''Human readable number format'''
        number = str(number)
        fnumber = number.split('.')
        # Does it have decimal places?
        if len(fnumber) == 2:
            # Remove '0' from the rights
            fnumber[1] = fnumber[1].rstrip('0')

            # Have at least two '0' on the right if the precision is equal or higher
            while len(fnumber[1]) < 2 and len(fnumber[1]) < precision:
                fnumber[1] = fnumber[1] + '0'
            # Fill up with spaces (for alignment)
            while len(fnumber[1]) < precision:
                fnumber[1] = fnumber[1] + ' '

            # Reconstruct
            number = fnumber[0] + '.' + fnumber[1]

        return number

    def __format_trade_row_values(self, values):
        '''
        Use extracted trade row value dictionary and format
        it nicely based on given colum settings.
        col_settings   Holds settings for each column
        colorize       Global setting that determines whether to apply colors.
        '''
        # Read settings into var for better readability
        col_settings = self.__col_settings
        colorize = self.__settings['color']
        humanize = self.__settings['human']

        clr = Color(colorize)
        fvalues = dict()
        for val in values:
            fvalues[val] = values[val]

            # 1. Rounding
            if col_settings[val]['prec'] is not None and fvalues[val]:
                fvalues[val] = Num.to_string(values[val], col_settings[val]['prec'])
            # 2. Humanize output
            if humanize:
                fvalues[val] = Coinwatch.__humanize_number(
                    fvalues[val],
                    col_settings[val]['prec']
                )
            # 3. Colorize
            if col_settings[val]['color'] and fvalues[val]:
                if values[val] < 0:
                    fvalues[val] = clr.red() + str(fvalues[val]) + clr.reset()
                else:
                    fvalues[val] = clr.green() + str(fvalues[val]) + clr.reset()
        return fvalues

    def __format_summary_row_values(self, totals):
        '''Format and return the summary row'''
        values = dict()
        values['name'] = 'TOTAL'
        values['date'] = ''
        values['buyprice'] = ''
        values['diffprice'] = ''
        values['nowprice'] = ''
        values['amount'] = ''
        values['invest'] = totals['invest']
        values['wealth'] = totals['wealth']
        values['profit'] = totals['profit']
        values['percent'] = Num.percent(totals['wealth'], totals['invest'])
        return self.__format_trade_row_values(values)

    def print_stats(self, currencies, trades):
        '''Print trading stats in a nice table'''

        # Total accumulated values
        totals = {
            'invest': Decimal('0.0'),
            'wealth': Decimal('0.0'),
            'profit': Decimal('0.0'),
        }

        # Get columns to to display and their settings
        display_columns = self.__settings['cols']
        col_settings = self.__col_settings

        # Initialize the table
        tbl = Table(COL_AVAILABLE, self.__settings['table'])
        tbl.set_col_widths({a: col_settings[a]['width'] for a in col_settings.keys()})
        tbl.set_col_aligns({a: col_settings[a]['align'] for a in col_settings.keys()})

        # # Add headline
        tbl.add_header_row({a: col_settings[a]['head'] for a in col_settings.keys()})

        for currency in currencies:

            # Do we track a currency?
            # (Remote currency is found in local config)
            if currency['id'] in trades:

                name = currency['id']

                # Only proceed if trade happened (defined in config)
                if trades[name]:
                    # Loop over trades in each currency
                    # (Each currency can have multiple trades on different dates/times)
                    for trade in trades[name]:

                        # Extract and format row values
                        values = self.__extract_trade_row_values(name, currency['price_usd'], trade)
                        fvalues = self.__format_trade_row_values(values)

                        # Add row
                        tbl.add_row(fvalues)

                        # Calculate total accumulated values
                        totals['invest'] = Num.sum(totals['invest'], values['invest'])
                        totals['wealth'] = Num.sum(totals['wealth'], values['wealth'])
                        totals['profit'] = Num.sum(totals['profit'], values['profit'])

        # Get overall summary
        fvalues = self.__format_summary_row_values(totals)

        # Add footer statistics
        tbl.add_footer_row(fvalues)

        # Draw table
        tbl.draw(display_columns, self.__settings['sort'], self.__settings['order'])


############################################################
# Helper Functions
############################################################

def logerr(*args):
    '''Error wrapper for print function'''
    print(''.join(map(str, args)), file=sys.stderr)


def to_yaml(string):
    '''Convert string to yaml'''
    try:
        data = yaml.load(string)
    except yaml.YAMLError as err:
        logerr('[ERR] Cannot convert string to yaml')
        logerr('[ERR] ', str(err))
        return dict()
    else:
        if data is None:
            return dict()
    return data


def to_json(string):
    '''Convert string to json'''
    try:
        data = json.loads(string)
    except ValueError as err:
        logerr('[ERR] Cannot convert to json')
        logerr('[ERR] ', str(err))
        return dict()
    else:
        if data is None:
            return dict()
    return data


############################################################
# Project Functions
############################################################

def print_version():
    '''Show program version'''
    print(NAME, 'v' + VERSION)
    print('Using Python ' + str(sys.version_info[0]) + '.' + str(sys.version_info[1]))
    print('MIT License - Copyright (c) 2018 cytopia')
    print('https://github.com/cytopia/coinwatch')


def print_help():
    '''Show program help'''
    print('''Usage: %s [-crsotnhv]
       %s [--help]
       %s [--version]

%s is a low-dependency python[23] client to keep track of your crypto trades
and easily let's you see if you are winning or losing. If you are not actually
trading you can use it to simulate purchases and see what would have happened if.

OPTIONS:
  -c, --config   Specify path of an alternative configuration file. Store
                 different configurations in different configuration files in
                 order to simulate multiple profiles.
                 Examples:
                   -c path/to/conf/john.yml
                   -c path/to/conf/jane.yml
  -r, --row      Specify the order and columns to use in a row. In case you
                 dont need all columns to be shown or want a different order of
                 columns, use this argument to specify it.
                 Available columns:
                   %s
                 Examples:
                   -r "coin date profit percent"
                   -r "coin buyprice nowprice amount wealth"
  -s, --sort     Specify the column name to sort this table.
                 See above for available columns.
                 The table can also be sorted against columns that are not displayed.
                 The default is 'name'.
  -o, --order    Specify the sorting order.
                 Valid orders: 'asc' and 'desc'.
                 The default order is 'asc'.
  -t, --table    Specify different table border. In case you need to process
                 the output of this tool use 'ascii'.
                 Available values: 'thin', 'thick' and 'ascii'.
                 The default is 'thin'.
                 Examples:
                   -t thin
                   -t thick
                   -t ascii
  -n, --nocolor  Disable shell colors. This is useful if you want to further
                 process the output of this program.
  -h, --human    Alternative human readable number format.
  -v, --verbose  Be verbose.

NOTE:
  No financial aid, support or any other recommendation is provided.
  Trade at your own risk! And only invest what you can effort to lose.

CONFIGURATION:
  When starting %s for the first time a base configuration file will be
  created in ~/.config/%s/config.yml''' %
          (NAME, NAME, NAME, NAME, ' '.join(COL_AVAILABLE), NAME, NAME))


def get_config_path():
    '''Get path of local config file'''
    home = os.path.expanduser('~')
    conf = os.path.join(home, '.config', NAME, 'config.yml')
    return conf


def read_config(path):
    '''Read trades from local yaml configuration file'''
    if not path:
        path = get_config_path()

    data = dict()
    if os.path.isfile(path):
        with open(path, 'r') as stream:
            data = to_yaml(stream)

    # Fill up defaults
    if 'trades' not in data:
        data['trades'] = dict()
    if 'config' not in data:
        data['config'] = dict()

    return data


def validate_config(config):
    '''Validate configuration file'''

    # Validate config
    if 'config' in config:
        # Columns
        if 'columns' in config['config'] and config['config']['columns']:
            for col in config['config']['columns'].split(' '):
                if col not in COL_AVAILABLE:
                    logerr('[ERR] Invalid column name in config: \'' + col + '\'')
                    logerr('[ERR] Valid column names: ' + ', '.join(COL_AVAILABLE))
                    sys.exit(2)
        # Sort
        if 'sort' in config['config'] and config['config']['sort']:
            sort = config['config']['sort']
            if sort not in COL_AVAILABLE:
                logerr('[ERR] Invalid sort column name in config: \'' + sort + '\'')
                logerr('[ERR] Valid sort column names: ' + ', '.join(COL_AVAILABLE))
                sys.exit(2)
        # Order
        if 'order' in config['config'] and config['config']['order']:
            order = config['config']['order']
            if order not in ('asc', 'desc'):
                logerr('[ERR] Invalid sort order in config: \'' + order + '\'')
                logerr('[ERR] Valid sort orders: \'asc\' and \'desc\'')
                sys.exit(2)
        # Table border
        if 'table' in config['config'] and config['config']['table']:
            if config['config']['table'] not in ('thin', 'thick', 'ascii'):
                logerr('[ERR] Invalid table border style in config: ' + config['config']['table'])
                logerr('[ERR] Allowed values: thin, thick and ascii')
                sys.exit(2)

    # Validate trades
    if not config['trades']:
        print('No trades found, check your config')
        sys.exit(0)


def build_settings(settings, config, default_columns, default_sort, default_order):
    '''Merge settings from command line and config file'''

    # Apply columns to display
    if settings['cols']:
        # Set via cmd args, all good
        pass
    elif 'columns' in config['config'] and config['config']['columns']:
        # Available in configuration file
        settings['cols'] = config['config']['columns'].split()
    else:
        # Nowhere set, use defaults
        settings['cols'] = default_columns

    # Apply column sort
    if settings['sort']:
        # Set via cmd args, all good
        pass
    elif 'sort' in config['config'] and config['config']['sort']:
        # Available in configuration file
        settings['sort'] = config['config']['sort']
    else:
        # Nowhere set, use defaults
        settings['sort'] = default_sort

    # Apply column sort order
    if settings['order']:
        # Set via cmd args, all good
        pass
    elif 'order' in config['config'] and config['config']['order']:
        # Available in configuration file
        settings['order'] = config['config']['order']
    else:
        # Nowhere set, use defaults
        settings['order'] = default_order

    # Apply table border settings
    if settings['table']:
        # Set via cmd args, all good
        pass
    elif 'table' in config['config'] and config['config']['table']:
        # Available in configuration file
        settings['table'] = config['config']['table']
    else:
        # Nowhere set, use defaults
        settings['table'] = 'thin'

    return settings


def bootstrap():
    '''Bootstrap the application'''
    conf_file = get_config_path()
    conf_dir = os.path.dirname(conf_file)

    if not os.path.isfile(conf_file):
        if not os.path.isdir(conf_dir):
            os.makedirs(conf_dir)

        pfile = open(conf_file, 'w')
        pfile.write(str(EXAMPLE_CONFIG))
        pfile.close()


def parse_args(argv, settings):
    '''Parse command line arguments.'''

    # Define command line options
    try:
        opts, argv = getopt.getopt(argv, 'c:r:s:o:t:nhv', [
            'version',
            'help',
            'config=',
            'row=',
            'sort=',
            'order=',
            'table=',
            'nocolor',
            'human',
            'verbose'
        ])
    except getopt.GetoptError as err:
        logerr('[ERR] ', err)
        logerr('Type --help for help')
        sys.exit(2)

    # Get command line options
    for opt, arg in opts:
        # Show help screen
        if opt == '--help':
            print_help()
            sys.exit()
        # Show version
        elif opt == '--version':
            print_version()
            sys.exit()
        # Custom rows to display in the given order
        elif opt in ('-r', '--row'):
            for col in arg.split(' '):
                if col not in COL_AVAILABLE:
                    logerr('[ERR] Invalid column name: \'' + col + '\'')
                    logerr('[ERR] Valid column names: ' + ', '.join(COL_AVAILABLE))
                    sys.exit(2)
            settings['cols'] = arg.split()
        # Get column to sort
        elif opt in ('-s', '--sort'):
            if arg not in COL_AVAILABLE:
                logerr('[ERR] Invalid sort column name: \'' + arg + '\'')
                logerr('[ERR] Valid sort column names: ' + ', '.join(COL_AVAILABLE))
                sys.exit(2)
            settings['sort'] = arg
        # Get sort order
        elif opt in ('-o', '--order'):
            if arg not in ('asc', 'desc'):
                logerr('[ERR] Invalid sort order: \'' + arg + '\'')
                logerr('[ERR] Valid sort orders: \'asc\' and \'desc\'')
                sys.exit(2)
            settings['order'] = arg
        # Choose table border
        elif opt in ('-t', '--table'):
            if arg not in('thin', 'thick', 'ascii'):
                logerr('[ERR] Invalid table border style: \'' + arg + '\'')
                logerr('[ERR] Allowed values: thin, thick and ascii')
                sys.exit(2)
            settings['table'] = arg
        # Use different config file
        elif opt in ('-c', '--config'):
            if not os.path.isfile(arg):
                logerr('[ERR] ' + opt + ' specified config does not exist: ' + arg)
                sys.exit(2)
            settings['path'] = arg
        # Disable color
        elif opt in ('-n', '--nocolor'):
            settings['color'] = False
        # Enable human readable number format
        elif opt in ('-h', '--human'):
            settings['human'] = True
        # Verbose output
        elif opt in ('-v', '--verbose'):
            settings['verbose'] = True

    return settings


############################################################
# Main Function
############################################################

def main(argv):
    '''Main entrypoint.'''

    # Default settings if not otherwise specified via config or cmd args
    settings = {
        'path':    None,     # Path to configuration file
        'color':   True,     # Colorize output
        'human':   False,    # Human readable number format
        'verbose': False,    # Verbosity?
        'table':   None,     # Table border style
        'sort':    None,     # Default sort
        'order':   None,     # Default sort order
        'cols':    dict()    # What columns in what order to display
    }

    # Bootstrap application (creating config & dir)
    bootstrap()

    # Get configuration from command line arguments
    settings = parse_args(argv, settings)

    # Read and validate configuration file
    config = read_config(settings['path'])
    validate_config(config)

    # Merge cmd args and config file settings
    settings = build_settings(settings, config, COL_DEFAULT, 'name', 'asc')

    # Get remote price info
    url = Fetch(True)
    try:
        currencies = to_json(url.fetch(API_URL))
    except HTTPError as err:
        logerr('[ERR] Cannot connect to %s' % (API_URL))
        logerr('[ERR] Error code: ', err.code)
        sys.exit(2)
    except URLError as err:
        logerr('[ERR] Cannot connect to %s' % (API_URL))
        logerr('[ERR] Reason:', err.reason)
        sys.exit(2)

    # Initialize and run Coinwatch
    cowa = Coinwatch({
        'color':  settings['color'],  # Colorize output?
        'human':  settings['human'],  # Humanize number output?
        'sort':   settings['sort'],   # Column to sort
        'order':  settings['order'],  # Sort order
        'table':  settings['table'],  # Table border style
        'cols':   settings['cols']    # Columns to display
    }, COL_SETTINGS)
    cowa.print_stats(currencies, config['trades'])


############################################################
# Main Entry Point
############################################################

if __name__ == '__main__':
    main(sys.argv[1:])
